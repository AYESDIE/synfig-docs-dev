Непрерывная интеграция
======================

Для непрерывной интеграции предлагается использовать сервис https://travis-ci.org.
Для сборки проекта c++ на travis-ci доступны виртуальные машины на базе Ubuntu Precise (12.04), Trusty (14.04) и OSX.

На данный момент (2018-04-27) у Precise закончился срок поддержки, но рекомендуется использовать её для сборки проектов, 
чтобы не поднимать требования к установленной в системе libc. (Вообще при компиляции можно выбрать с какой
libc компилировать, нужно будет проверить).

Подключение travis-ci
~~~~~~~~~~~~~~~~~~~~~
Для подключения нужно зарегистрироваться на travis-ci, и добавить этот сервис в github (по сути это хук, который будет
вызываться при пуше в репозиторий). Дальнейшие указания travis передаются через файл .travis.yml, который должен быть
размещён в корне проекта. Сборка проекта происходит в несколько стадий:
* preinstall - на этой стадии можно загрузить и установить необходимые зависимости в виртуальную машину, где будет происходить сборка;
* build (script) - этап сборки;
* depoly - этап развёртывания.

Для развёртывания необходимо передавать логины/пароли travis для подключения к нужным сервисам. В некоторых howto показывают
как использовать gem travis для того, чтобы зашифровать пароль и этот зашифрованный пароль будет храниться в файле конфигурации.
Есть более правильный способ - это зайти в настройки проекта на сайте travis и указать конфиденциальные данные в переменных окружения.
Там есть галочка, включающая/отключающая отображение значения этой переменной в логах. Затем эти переменные использовать в скриптах.

Этап развёртывания
~~~~~~~~~~~~~~~~~~
Изначально планировалось загружать скомпилированные файлы в Github Releases, однако тут возникло несколько проблем.
В релизы добавляются только именованные (tag) коммиты. Если у коммита нет тэга, то при загрузке релиза он будет создан автоматически.
Это приводит нас к первой проблеме - создание нового тэга и пуш в репозиторий приведёт к повторному билду проекта.
Согласно документации билд можно пропустить, если в commit message указать "[skip ci]" или "[ci skip]". Однако, при использовании ключа 
git push --tags и git tag, коммит не создаётся (специально, чтобы не засорять историю) и travis не пропускает сборку (хотя тэг добавляется).

Также можно пушить в ветку, которая не отслеживается travis (не знаю, насколько это удобно).

Есть другой вариант решения проблемы: разрешать собирать только именованные коммиты. В таком случае пуш для создания тэга становится не нужным, 
и повторной сборки не происходит. Из минусов: если в имени файла содержится номер билда (как и должно быть), то эти файлы будут накапливаться
в релизе (если мы используем релиз с одним имененем, например, latest). Отсюда второй минус: очистку релиза от старых файлов нужно будет делать
вручную, за своевременной сборкой тоже следить вручную. Также пока непонятно, будет ли происходить автоматическая сборка для PR 
(там я полагаю тоже тэга нет).

Второй вариант: размещаем бинарники на bitray или у себя на хостинге.

